# 程序员常用10种算法

## 1. 二分查找算法(非递归)

### 1.1 二分查找算法(非递归)介绍

### 1.2 二分查找算法(非递归)代码实现

## 2. 分治算法

### 2.1 分治算法介绍

### 2.2 分治算法的基本步骤

### 2.3 分治(Divide-and-Conquer(p))算法设计模式如下

### 2.4 分治算法最佳实践-汉诺塔

## 3. 动态规划算法

### 3.1 应用场景-背包问题

### 3.2 动态规划算法介绍

### 3.3 动态规划算法最佳实践-背包问题

### 3.4 动态规划-背包问题代码实现

## 4. KMP算法

### 4.1 应用场景-字符串匹配问题

### 4.2 暴力匹配算法

### 4.3 KMP算法介绍

### 4.4 KMP算法最佳应用-字符串匹配问题



## 5. 贪心算法

### 5.1 应用场景-集合覆盖问题

### 5.2 贪心算法介绍

### 5.3 贪心算法最佳应用-集合覆盖

### 5.4 贪心算法注意事项和细节

## 6. 普里姆算法

### 6.1 应用场景-修路问题

### 6.2 最小生成树

### 6.3 普里姆算法介绍

### 6.4 普里姆算法最佳实践(修路问题)

## 7. 克鲁斯卡尔算法

### 7.1 应用场景-公交站问题

### 7.2 克鲁斯卡尔算法介绍

### 7.3 克鲁斯卡尔算法图解说明

#### 7.3.1 克鲁斯卡尔算法图解

#### 7.3.2 克鲁斯卡尔算法分析

#### 7.3.3 如何判断是否构成回路-举例说明(如图)

#### 7.3.4 克鲁斯卡尔算法的代码说明

### 7.4 克鲁斯卡尔最佳实践-公交站问题



## 8. 迪杰斯特拉算法

### 8.1 应用场景-最短路径问题

### 8.2 迪杰斯特拉(Dijkstra)算法介绍

### 8.3 迪杰斯特拉(Dijkstra)算法过程

### 8.4 迪杰斯特拉(Dijkstra)算法最佳应用-最短路径

## 9. 弗洛伊德算法

### 9.1 费罗伊德(Floud)算法介绍

### 9.2 费罗伊德(Floud)算法图解分析

### 9.3 费罗伊德(Floud)算法最佳应用-最短路径

## 10. 马踏棋盘算法

### 10.1 马踏棋盘算法介绍和游戏演示



### 10.2 马踏棋盘游戏代码演示