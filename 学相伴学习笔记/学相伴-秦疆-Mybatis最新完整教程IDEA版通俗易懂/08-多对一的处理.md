# 多对一的处理

> 多对一的理解：
>
> - 多个学生对应一个老师
>
> - 如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师！

## 1. 数据库设计

```sql
CREATE TABLE `teacher` ( 
    `id` INT(10) NOT NULL, 
    `name` VARCHAR(30) DEFAULT NULL, 
    PRIMARY KEY (`id`) 
) ENGINE=INNODB DEFAULT CHARSET=utf8 
INSERT INTO teacher(`id`, `name`) VALUES (1, '秦老师'); 

CREATE TABLE `student` ( 
    `id` INT(10) NOT NULL, 
    `name` VARCHAR(30) DEFAULT NULL, 
    `tid` INT(10) DEFAULT NULL, 
    PRIMARY KEY (`id`),
    KEY `fktid` (`tid`), 
    CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`) 
) ENGINE=INNODB DEFAULT CHARSET=utf8 
INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('1', '小明', '1'); 
INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('2', '小红', '1'); 
INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('3', '小张', '1'); 
INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('4', '小李', '1'); 
INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('5', '小王', '1');
```



## 2. 搭建测试环境

【Lombok的使用】
1. IDEA安装Lombok插件

2. 引入Maven依赖

   ```xml
   <!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --> 
   <dependency> 
       <groupId>org.projectlombok</groupId> 
       <artifactId>lombok</artifactId> 
       <version>1.16.10</version> 
   </dependency>
   ```

3. 在代码中增加注解

   ```java
   @Data //GET,SET,ToString，有参，无参构造 
   public class Teacher { 
       private int id; private String name; 
   }
   ```

   ```java
   @Data public class Student { 
       private int id; private String name; //多个学生可以是同一个老师，即多对一 
       private Teacher teacher; 
   }
   ```

4. 编写实体类对应的Mapper接口 【两个】**ps: 无论有没有需求，都应该写上，以备后来之需！**

   ```java
   public interface StudentMapper {
       
   }
   ```

   ```java
   public interface TeacherMapper {
       
   }
   ```

5. 编写Mapper接口对应的 mapper.xml配置文件 【两个】**ps:无论有没有需求，都应该写上，以备后来之需！ **

   ```xml
   <?xml version="1.0" encoding="UTF-8" ?> 
   		<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
   		"http://mybatis.org/dtd/mybatis-3-mapper.dtd"> 
   <mapper namespace="com.kuang.mapper.StudentMapper"> 
   
   </mapper>
   ```

   ```xml
   <?xml version="1.0" encoding="UTF-8" ?> 
   		<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
   		"http://mybatis.org/dtd/mybatis-3-mapper.dtd"> 
   <mapper namespace="com.kuang.mapper.TeacherMapper"> 
   
   </mapper>
   ```

   

   



## 3. 按查询嵌套处理

1. 给StudentMapper接口增加方法

   ```java
   //获取所有学生及对应老师的信息 
   public List<Student> getStudents();
   ```

2. 编写对应的Mapper文件

   ```xml
   <?xml version="1.0" encoding="UTF-8" ?> 
   		<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
   		"http://mybatis.org/dtd/mybatis-3-mapper.dtd"> 
   <mapper namespace="com.kuang.mapper.StudentMapper"> 
       <!-- 需求：获取所有学生及对应老师的信息 
      思路：1. 获取所有学生的信息 
        2. 根据获取的学生信息的老师ID->获取该老师的信息 
        3. 思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般 使用关联查询？ 
        	1. 做一个结果集映射：StudentTeacher 
        	2. StudentTeacher结果集的类型为 Student 
        	3. 学生中老师的属性为teacher，对应数据库中为tid。 多个 [1,...）学生关联一个老师=> 一对一，一对多 	
        	4. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查 询 
      --> 
       <select id="getStudents" resultMap="StudentTeacher"> 
           select * from student 
       </select> 
       <resultMap id="StudentTeacher" type="Student"> 
           <!--association关联属性 property属性名 javaType属性类型 column在多 的一方的表中的列名-->
           <association property="teacher" column="tid" javaType="Teacher" select="getTeacher"/> 
       </resultMap> 
       <!-- 这里传递过来的id，只有一个属性的时候，下面可以写任何值 association中column多参数配置： column="{key=value,key=value}" 其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的 字段名。--> 
       <select id="getTeacher" resultType="teacher"> 
           select * from teacher where id = #{id} 
       </select> 
   </mapper>
   ```

3. 编写完毕去Mybatis配置文件中，注册Mapper！ 

4.  注意点说明：

   ```xml
   <resultMap id="StudentTeacher" type="Student"> 
       <!--association关联属性 property属性名 javaType属性类型 column在多的一方 的表中的列名--> 
       <association property="teacher" column="{id=tid,name=tid}" javaType="Teacher" select="getTeacher"/> 
   </resultMap> 
   <!-- 这里传递过来的id，只有一个属性的时候，下面可以写任何值 association中column多参数配置： column="{key=value,key=value}" 其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段 名。--> 
   <select id="getTeacher" resultType="teacher"> 
       select * from teacher where id = #{id} and name = #{name} 
   </select>
   ```

5.  测试

   ```java
   @Test public void testGetStudents(){ 
       SqlSession session = MybatisUtils.getSession(); 
       StudentMapper mapper = session.getMapper(StudentMapper.class); 
       List<Student> students = mapper.getStudents(); 
       for (Student student : students){ 
           System.out.println( "学生名:"+ student.getName() +"\t老师:"+student.getTeacher().getName()); 
       } 
   }
   ```

   

## 4. 按结果嵌套处理

除了上面这种方式，还有其他思路吗？

我们还可以按照结果进行嵌套处理；

1. 接口方法编写

   ```java
   public List<Student> getStudents2();
   ```

2. 编写对应的mapper文件

   ```xml
   <!-- 按查询结果嵌套处理 
   思路：1. 直接查询出结果，进行结果集的映射 
   --> 
   <select id="getStudents2" resultMap="StudentTeacher2" > 
       select s.id sid, s.name sname , t.name tname from student s,teacher t where s.tid = t.id </select> 
   <resultMap id="StudentTeacher2" type="Student"> 
       <id property="id" column="sid"/>
       <result property="name" column="sname"/> <!--关联对象property 关联对象在Student实体类中的属性--> 
       <association property="teacher" javaType="Teacher"> 
           <result property="name" column="tname"/> 
       </association> 
   </resultMap>
   ```

3. 去mybatis-confifig文件中注入【此处应该处理过了】

4. 测试

   ```java
   @Test public void testGetStudents2(){ 
       SqlSession session = MybatisUtils.getSession(); 
       StudentMapper mapper = session.getMapper(StudentMapper.class); 
       List<Student> students = mapper.getStudents2(); 
       for (Student student : students){ 
           System.out.println( "学生名:"+ student.getName() +"\t老师:"+student.getTeacher().getName()); 
       } 
   }
   ```

   



**小结**: 

- 按照查询进行嵌套处理就像SQL中的子查询
- 按照结果进行嵌套处理就像SQL中的联表查询

